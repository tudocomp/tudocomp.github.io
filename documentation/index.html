<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale = 1, maximum-scale=1, user-scalable=no"/>
    <!-- TODO: Meta / OpenGraph / Facebook -->
    <title>tudocomp &ndash; Documentation</title>
    <link rel="stylesheet" type="text/css" href="../fonts/fonts.css"/>
    <link rel="stylesheet" type="text/css" href="style-pandoc.css"/>
    <link rel="stylesheet" type="text/css" href="style.css"/>
    <link rel="icon" type="image/svg+xml" href="../tudocomp-icon.svg">
    <!-- Chrome currently doesn't support SVG favicons -->
    <link rel="icon" type="image/png" href="../tudocomp-icon.png">
</head>
<body>
    <header>
        <h1>&ndash; The TU Dortmund Compression Framework</h1>
    </header>
    <section id="content">
        <div>
            <div id="document-info">
                <div id="title">tudocomp</div>
                <div id="subtitle">Documentation of the TU Dortmund Compression Framework</div>
                <div id="author">Dominik K&ouml;ppl, Patrick Dinklage, Marvin L&ouml;bel</div>
                <div id="date">2017</div>
            </div>

            <h1>Table of Contents</h1> <!-- Pandoc seems to be missing this -->
            <div id="TOC">
<ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#philosophy">Philosophy</a><ul>
<li><a href="#compressors-and-coders">Compressors and Coders</a></li>
<li><a href="#modularity">Modularity</a></li>
<li><a href="#library-and-command-line">Library and Command-Line</a></li>
</ul></li>
<li><a href="#features">Features</a></li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#building">Building</a><ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#documentation-build-requirements">Documentation Build Requirements</a></li>
<li><a href="#windows-support">Windows Support</a></li>
</ul></li>
<li><a href="#command-line-tool">Command-line Tool</a></li>
<li><a href="#library">Library</a></li>
<li><a href="#license">License</a></li>
</ul></li>
<li><a href="#tutorial">Tutorial</a><ul>
<li><a href="#unit-tests">Unit Tests</a><ul>
<li><a href="#registering-and-running-unit-tests">Registering and running unit tests</a></li>
</ul></li>
<li><a href="#input-and-output">Input and Output</a><ul>
<li><a href="#reading-an-input">Reading an Input</a></li>
<li><a href="#producing-an-output">Producing an Output</a></li>
<li><a href="#bitwise-io">Bitwise I/O</a></li>
</ul></li>
<li><a href="#arbitrary-width-integer-vectors">Arbitrary-Width Integer Vectors</a></li>
<li><a href="#algorithms">Algorithms</a><ul>
<li><a href="#meta-information">Meta Information</a></li>
<li><a href="#environment">Environment</a></li>
<li><a href="#options">Options</a></li>
<li><a href="#strategies">Strategies</a></li>
<li><a href="#instantiating-algorithms">Instantiating Algorithms</a></li>
<li><a href="#the-algorithm-registry">The Algorithm Registry</a></li>
</ul></li>
<li><a href="#coders">Coders</a><ul>
<li><a href="#ranges">Ranges</a></li>
<li><a href="#literal-iterators">Literal Iterators</a></li>
<li><a href="#the-coder-interface">The Coder Interface</a></li>
<li><a href="#interleaved-coding">Interleaved Coding</a></li>
<li><a href="#available-coders">Available Coders</a></li>
</ul></li>
<li><a href="#compressors">Compressors</a><ul>
<li><a href="#available-compressors">Available Compressors</a></li>
<li><a href="#compressor-test-helpers">Compressor Test Helpers</a></li>
<li><a href="#magic">Magic</a></li>
</ul></li>
<li><a href="#string-generators">String Generators</a><ul>
<li><a href="#available-string-generators">Available String Generators</a></li>
</ul></li>
<li><a href="#runtime-statistics">Runtime Statistics</a><ul>
<li><a href="#charter-web-application">Charter Web Application</a></li>
</ul></li>
<li><a href="#text-corpus">Text Corpus</a><ul>
<li><a href="#downloading-the-text-corpus">Downloading the Text Corpus</a></li>
</ul></li>
<li><a href="#the-comparison-tool">The Comparison Tool</a><ul>
<li><a href="#comparison-suites">Comparison Suites</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="abstract">Abstract</h1>
<p>The <strong>T</strong>echnical <strong>U</strong>niversity of <strong>DO</strong>rtmund <strong>COMP</strong>ression Framework, <em>tudocomp</em>, is a lossless compression framework with the aim to support and facilitate the implementation of novel compression algorithms. It already comprises a range of standard data compression and encoding algorithms. These can be mixed and parameterized with the following uses in mind:</p>
<ul>
<li>Baseline implementations of well-known compression schemes.</li>
<li>Detailed benchmarking and comparison of compression and encoding algorithms.</li>
<li>Easy integration of new algorithm implementations.</li>
</ul>
<h1 id="philosophy">Philosophy</h1>
<p>The framework offers a solid and extensible base for new implementations. It is designed so that most individual processes are modularized and interchangeable. This way, the user can mix and match algorithms to find the optimal compression strategy for a given input. The framework gives this opportunity while creating as little performance overhead as possible.</p>
<h2 id="compressors-and-coders">Compressors and Coders</h2>
<p><em>Compressors</em>, in terms of this framework, transform an input sequence (of bytes or characters) and write the result to an output. Each compressor is also required to implement a <em>decompressor</em> that can restore the original input losslessly from the compressed output. Apart from this, there are no strict rules as to <em>what</em> kind of transformation of the input occurs.</p>
<p><em>Coders</em> serve for encoding primitve data types into a bit sequence with limited context (contrary to compressors, which may randomly access the entire input sequence). To this end, coders conceptually form the end of a compression chain by producing the final output bit sequence. A coder may receive additional information by a compressor in order to be able to encode data more efficiently (e.g. value ranges for bit-optimal encoding or even an alphabet distribution for low-entropy encoding). Analogously to compressors, every coder must be accompanied by a matching <em>decoder</em>.</p>
<p>By design, a <em>coder</em> can also be used as a compressor.</p>
<h2 id="modularity">Modularity</h2>
<p>Compressors and coders form a subset of our concept of <em>algorithms</em>. Any non-trivial type to be exposed to users by <em>tudocomp</em> shall be seen as an algorithm.</p>
<p>Algorithms shall be implemented in a <em>modular</em> way. Modules shall be interchangeable, so any task or subtask may be approached using different strategies.</p>
<p>For instance, picture a compression algorithm that consists of more than one step to achieve its compression or decompression. If each step could be seen as a module that may solve its sub-task in different ways, it qualifies for modularization.</p>
<p>To achieve this kind of modularity, the use of C++'s meta programming features (namely templates) is heavily encouraged. <em>tudocomp</em> is designed in a way that allows template parameters to be populated seemingly at runtime.</p>
<p>Furthermore, compressors and coders can be chained so that the output of one becomes the input of another.</p>
<h2 id="library-and-command-line">Library and Command-Line</h2>
<p>The framework consists of two major components: the compression <em>library</em> (often used synonymously with <em>tudocomp</em> in this document) and the command-line application (<code>tdc</code>).</p>
<p>The library contains the core interfaces and provides implementations for various compression algorithms. It is fully functional for use in third-party applications.</p>
<p>Using <code>tdc</code> (the commmand-line application), <em>tudocomp</em>'s implementations can be invoked from a shell.</p>
<p>The interface between <em>tudocomp</em> and <code>tdc</code> is the <em>registry</em>. Every registered algorithm is exposed to <code>tdc</code> with a unique identifier specified by its implementation.</p>
<h1 id="features">Features</h1>
<p><em>tudocomp</em> includes the following set of features:</p>
<ul>
<li>Flexible template-based interface for algorithms (e.g. compressors or integer encoders)
<ul>
<li>Registry for easy exposition to the <code>tdc</code> command-line tool</li>
<li>Definition of parameters that can be passed (e.g. via the command-line)</li>
<li>On-the-fly population of template parameters for easy exchangability of strategies and other modules (also via the command-line)</li>
</ul></li>
<li>Simple interface for compressors</li>
<li>Powerful interface for integer encoders
<ul>
<li>Possibility to receive context information from compressors, such as integer value ranges or the input alphabet, for more efficient encoding capabilities</li>
</ul></li>
<li>Arbitrary-width integer vectors and bit vectors</li>
<li>Bitwise I/O</li>
<li>Measurement of running time and heap allocation in freely definable and nestable code phases
<ul>
<li><code>malloc</code> override</li>
<li>Export of statistics to JSON</li>
<li>Visualization of exported statistics in a web application</li>
<li>Export of charts to <code>png</code> or <code>svg</code> (<a href="https://inkscape.org/">InkScape</a>-compatible<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> and LaTeX-friendly)</li>
</ul></li>
<li>Implementations of text data structures, including
<ul>
<li>Suffix array (using <code>divsufsort</code>) and inverse</li>
<li>LCP array and its pre-stages (Phi array and permuted LCP)</li>
<li>Burrows-Wheeler transform and LF table</li>
<li>Optional bit-compression either during or after construction</li>
</ul></li>
<li>Implementations of various integer encoders, including:
<ul>
<li>Binary and unary encoding</li>
<li>Elias-Gamma and -Delta encoding</li>
<li>VByte coding</li>
<li>Huffman coding</li>
<li>Human-readable ASCII representation for debugging purposes</li>
<li>Custom static low-entropy encoding (SLE)</li>
</ul></li>
<li>Implementations of various compression algorithms, including:
<ul>
<li>LZ77 using a sliding window or the LCP array</li>
<li>LZ78 with exchangeable trie structure</li>
<li>Run-length encoding</li>
<li>Custom variants of LZ77 (lcpcomp) and LZ78 (LZ78U) (see <a href="http://dkppl.de/static/bin/paper/sea2017.pdf">here</a>)</li>
</ul></li>
<li>Utilities for swift unit test implementation</li>
<li>String generators for testing and benchmarking purposes
<ul>
<li>Random strings with uniform character distribution</li>
<li>Fibonacci words</li>
<li>Thue-Morse strings</li>
<li>Run-Rich strings (Matsubara et al.)</li>
</ul></li>
<li>Scripts for downloading a text corpus for testing and benchmarking purposes</li>
<li>Tools to compare running time, heap memory usage and compression ratio of different compressor suites (<em>tudocomp</em> as well as third-party) on a freely definable set of inputs</li>
</ul>
<h1 id="usage">Usage</h1>
<p>This section describes the usage of <em>tudocomp</em> as a <code>C++</code> library and as a command-line tool, respectively.</p>
<h2 id="building">Building</h2>
<p>The framework is built using <a href="https://cmake.org">CMake</a> (3.0.2 or later). It is written in <code>C++14</code> with GNU extensions and has been tested with the <code>gcc</code> compiler family (version 5.4 or later) and <code>clang</code> (version 3.4 or later). The build process requires a <a href="https://www.python.org/">Python</a> interpreter (3 or later) to be installed on the system (<code>py</code> scripts are invoked directly).</p>
<p>When these requirements are met, the following chain of commands on a clean clone of the project suffices to build <em>tudocomp</em>:</p>
<pre><code>$ mkdir build &amp;&amp; cd build
$ cmake ..
$ make</code></pre>
<p>Note that <em>tudocomp</em> is configured for a debug build by default. The build type can be changed by passing the <code>CMAKE_BUILD_TYPE</code> corresponding parameter to CMake:</p>
<ul>
<li>Debug build (default): <code>cmake -DCMAKE_BUILD_TYPE=Debug ..</code></li>
<li>Release build: <code>cmake -DCMAKE_BUILD_TYPE=Release ..</code></li>
</ul>
<p>For benchmarking purposes, the Release configuration is heavily recommended, as it will tell the compiler to perform numerous optimizations.</p>
<h3 id="dependencies">Dependencies</h3>
<p><em>tudocomp</em>'s CMake build process will either find external dependencies on the system if they have been properly installed, or automatically download and build them from their official repositories in case they cannot be found. In that regard, a proper installation of the dependencies is not required.</p>
<p>Said external dependencies are the following:</p>
<ul>
<li><a href="https://github.com/simongog/sdsl-lite">SDSL</a> (2.1 or later).</li>
<li><a href="https://github.com/google/glog">Google Logging (glog)</a> (0.34 or later).</li>
</ul>
<p>Additionally, the tests require <a href="https://github.com/google/googletest">Google Test</a> (1.7.0 or later).</p>
<h3 id="documentation-build-requirements">Documentation Build Requirements</h3>
<p>For building the documentation, the following tools need to be installed:</p>
<ul>
<li><a href="http://www.latex-project.org">LaTeX</a> (specifically the <code>pdflatex</code> component)</li>
<li><a href="http://doxygen.org">Doxygen</a> (1.8 or later).</li>
<li><a href="http://pandoc.org">Pandoc</a> (1.19 or later).</li>
</ul>
<h3 id="windows-support">Windows Support</h3>
<p>While <em>tudocomp</em> has no explicit support Windows / Microsoft Visual C++, it is possible to use the <a href="https://msdn.microsoft.com/en-us/commandline/wsl/about">Bash on Ubuntu on Windows</a> with next to no feature limitations. However, note that <a href="#the-comparison-tool">the comparison tool</a> relies on <code>valgrind</code>, which is not functional in this environment until the <a href="https://blogs.windows.com/windowsexperience/2017/04/11/whats-new-in-the-windows-10-creators-update">Windows 10 Creators Update</a> <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<h2 id="command-line-tool">Command-line Tool</h2>
<p>The executable <code>tdc</code> is the command-line application that bundles all compression, encoding and other algorithms contained in <em>tudocomp</em>. It provides a fast and easy way to compress and decompress a file with a specified compressor or chain of compressors.</p>
<p>It contains a common help output that can be accessed by passing <code>--help</code>. Furthermore, the aforementioned set of algorithms that are available for use via the command-line can be listed by passing <code>--list</code>.</p>
<p>The following are typical ways to use <code>tdc</code> and should give an idea about how to use it. The example is using a simple LZ77 compressor and human readable encoding.</p>
<dl>
<dt>Compress <code>file.txt</code>, write to <code>file.txt.tdc</code>:</dt>
<dd><code>$ tdc -a &quot;lzss(coder=ascii)&quot; file.txt</code>
</dd>
<dt>Compress to a specific output file, overwrite if it exists:</dt>
<dd><code>$ tdc -a &quot;lzss(coder=ascii)&quot; file.txt -fo out.tdc</code>
</dd>
<dt>Decompress a compressed file, print to stdout:</dt>
<dd><code>$ tdc -d out.tdc --usestdout</code>
</dd>
<dt>Decompress using a specific decompressor, print to stdout:</dt>
<dd><code>$ tdc -d -a &quot;encode(coder=ascii)&quot; --stdout</code>
</dd>
<dt>Print the 10<sup>th</sup> Fibonacci word to stdout:</dt>
<dd><code>$ tdc -g &quot;fib(10)&quot; --usestdout</code>
</dd>
<dt>Compress the 10<sup>th</sup> Fibonacci word, print to stdout without header:</dt>
<dd><code>$ tdc -g &quot;fib(10)&quot; -a &quot;lzss(coder=ascii)&quot; --raw --usestdout</code>
</dd>
</dl>
<h4 id="chaining">Chaining</h4>
<p>Compressors and coders can be chained so that the output of one becomes the input of another.</p>
<dl>
<dt>Chain the Burrows-Wheeler transform of a file into run-length, move-to-front and Huffman coding:</dt>
<dd><code>$ tdc -a &quot;bwt:rle:mtf:encode(huff)&quot; file.txt</code>
</dd>
</dl>
<h2 id="library">Library</h2>
<p>The library part of <em>tudocomp</em> is generated as the <code>libtudocomp_algorithms.a</code> artifact that can be used for static linking. Using this and the headers (located in the <code>include</code> directory tree), <em>tudocomp</em> can be used as an external library in third-party applications.</p>
<p>The <a href="../doxygen">Doxygen documentation</a> provides an overview of the framework's full API, including the contained compression and encoding implementations.</p>
<h2 id="license">License</h2>
<p>The framework is published under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a>.</p>
<h1 id="tutorial">Tutorial</h1>
<p>This section provides a guided tour through some of the core features of <em>tudocomp</em>.</p>
<p>Please note that more detailed information about the use of specific classes or methods can be found in the <a href="../doxygen">Doxygen documentation</a>.</p>
<blockquote>
<p><em>Hint</em>: Most code snippets can be seen &quot;in action&quot; in the directory <code>test/doc_snippets</code>. These can be used as a reference. The source code file name is printed below the respective code snippet. Note that the snippets are implemented as unit tests, while this document will only show the didactically relevant parts.</p>
</blockquote>
<h2 id="unit-tests">Unit Tests</h2>
<p>Because the documentation snippets are implemented as unit tests, this first section gives a brief overview over how these are hooked. The unit tests are powered by the <a href="https://github.com/google/googletest">Google Test</a> library. Note that an explanation of the Google Test API is not part of this documentation. However, <em>tudocomp</em> provides some test helpers that will be presented in the respective sections.</p>
<h3 id="registering-and-running-unit-tests">Registering and running unit tests</h3>
<p>All test sources are located in the <code>test</code> directory in the repository root. The test source files categorize unit tests into test suites and are registered in the <code>CMakeLists.txt</code> file.</p>
<p>The generated Makefile contains a target for registered each test suite. For example, the command-line <code>make tudocomp_tests</code> (from a build directory) invokes the <code>tudocomp_tests</code> suite, which is contained in <code>tudocomp_tests.cpp</code>. The <code>check</code> target executes all registered test suites in succession.</p>
<p>The <code>sandbox_tests</code> suite is ignored by the framework's repository and can be used for quick developmental tests to avoid the registration procedure. It can also be used as a template for new test suites.</p>
<h2 id="input-and-output">Input and Output</h2>
<p><em>tudocomp</em> provides an abstraction for handling input from different kinds of sources and output to different kinds of targets. These are straightforwardly named <a href="../doxygen/classtdc_1_1io_1_1_input.html"><code>Input</code></a> and <a href="../doxygen/classtdc_1_1io_1_1_output.html"><code>Output</code></a>. Both hide the actual source or target of the data (e.g. a file or memory buffer).</p>
<p>This section will describe their usage briefly along with some examples.</p>
<h3 id="reading-an-input">Reading an Input</h3>
<p>An <a href="../doxygen/classtdc_1_1io_1_1_input.html"><code>Input</code></a> can be created from different data sources:</p>
<ul>
<li>a memory pointer (e.g. a string literal),</li>
<li>a byte buffer (<code>std::vector&lt;uint8_t&gt;</code>),</li>
<li>a file or</li>
<li>an input stream (<code>std::istream</code>)<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</li>
</ul>
<p>For each type of data source, the <code>Input</code> class provides a corresponding constructor:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Create an Input from a string literal</span>
Input input_from_string(<span class="st">&quot;This is the input text&quot;</span>);

<span class="co">// Create an Input from a given byte buffer (std::vector&lt;uint8_t&gt;)</span>
Input input_from_buffer(buffer);

<span class="co">// Create an Input from a file</span>
Input input_from_file(Path(<span class="st">&quot;example.txt&quot;</span>));

<span class="co">// Create an Input from a given std::istream</span>
Input input_from_stream(<span class="bu">std::</span>cin); <span class="co">// from stdin</span></code></pre></div>
<p>The input can be accessed in two conceptually different ways:</p>
<ol style="list-style-type: decimal">
<li>As a <em>stream</em>, so that bytes are read sequentially from the input source (the concept of online algorithms) or</li>
<li>as a <em>view</em>, providing random access to the input source like to an array of bytes (the concept of offline algorithms).</li>
</ol>
<p>The choice is done by acquiring the respective handle using either the <a href="../doxygen/classtdc_1_1io_1_1_input.html#af4579b9d8cfa928fa931038579975860"><code>as_stream</code></a> or the <a href="../doxygen/classtdc_1_1io_1_1_input.html#a01b43ae61e9c5097de455407940be1ff"><code>as_view</code></a> function. The stream object returned by <code>as_stream</code> conforms to the <code>std::istream</code> interface and also provides iterator access. The <a href="../doxygen/classtdc_1_1_const_generic_view.html"><code>View</code></a> object returned by <code>as_view</code> provides the indexed access <code>[]</code> operator for and the function <a href="../doxygen/classtdc_1_1_const_generic_view.html#aa4b22be55a0f0160e447f03cabe64e5c"><code>size</code></a> to return the amount of bytes available on the input.</p>
<p>The following code snippet demonstrates using a given input as a stream:</p>
<div class="sourceCode" caption="io.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> istream = input.as_stream(); <span class="co">// retrieve an input stream</span>

<span class="co">// read the input character-wise using a range-based for loop</span>
<span class="cf">for</span>(<span class="dt">uliteral_t</span> c : istream) {
    <span class="co">// ...</span>
}</code></pre></div>
<p>The type <a href="../doxygen/namespacetdc.html#a83a48cf82def7e8690fa0f1c92996486"><code>uliteral_t</code></a> is one of <em>tudocomp</em>'s core types and shall be used for single characters.</p>
<p>In contrast, The following code snippet demonstrates using an input as a view:</p>
<div class="sourceCode" caption="io.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> iview = input.as_view(); <span class="co">//retrieve an input view</span>

<span class="co">// compare the view&#39;s content against a certain string</span>
ASSERT_EQ(<span class="st">&quot;foobar&quot;</span>, iview);

<span class="co">// create a sub-view for a range within the main view</span>
<span class="kw">auto</span> sub_view = iview.substr(<span class="dv">1</span>, <span class="dv">5</span>);

ASSERT_EQ(<span class="st">&quot;ooba&quot;</span>, sub_view); <span class="co">// assertion for the sub-view&#39;s contents</span>

<span class="co">// iterate over the whole view character-wise in reverse order</span>
<span class="cf">for</span> (<span class="dt">len_t</span> i = iview.size(); i &gt; <span class="dv">0</span>; i--) {
    <span class="dt">uliteral_t</span> c = iview[i<span class="dv">-1</span>];
    <span class="co">// ...</span>
}</code></pre></div>
<p>The type <a href="../doxygen/namespacetdc.html#aa6b4c54c0897b49bf3c9e3f9f71ec408"><code>len_t</code></a> is another one of <em>tudocomp</em>'s core types and shall be used for lengths and indices.</p>
<p>The functions <code>as_stream</code> and <code>as_view</code> can be used arbitrarily often to create multiple streams or views on the same input, e.g., in case the input is to be streamed more than once.</p>
<h3 id="producing-an-output">Producing an Output</h3>
<p>An <a href="../doxygen/classtdc_1_1io_1_1_output.html"><code>Output</code></a> can be created for different data sinks:</p>
<ul>
<li>a byte buffer (<code>std::vector&lt;uint8_t&gt;</code>),</li>
<li>a file or</li>
<li>an output stream (<code>std::ostream</code>).</li>
</ul>
<p>Like <code>Input</code>, it provides a constructor for each type of sink:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Create an Output to a given byte buffer (std::vector&lt;uint8_t&gt;)</span>
Output output_to_buffer(buffer);

<span class="co">// Create an Output to a file:</span>
Output output_to_file1(Path(<span class="st">&quot;example.txt&quot;</span>), <span class="kw">false</span>); <span class="co">// do not overwrite if exists (default)</span>
Output output_to_file2(Path(<span class="st">&quot;example.txt&quot;</span>), <span class="kw">true</span>); <span class="co">// overwrite if exists</span>

<span class="co">// Create an Output to a given std::ostream</span>
Output output_to_stream(<span class="bu">std::</span>cout); <span class="co">// to stdout</span></code></pre></div>
<p>An output has to be generated sequentially and thus only provides a stream interface via the <a href="../doxygen/classtdc_1_1io_1_1_output.html#a8364101b7db65104e44d78738611de60"><code>as_stream</code></a> function. The following code snippet demonstrates this by copying an entire input to an output:</p>
<div class="sourceCode" caption="io.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> istream = input.as_stream(); <span class="co">// retrieve the input stream</span>
<span class="kw">auto</span> ostream = output.as_stream(); <span class="co">// retrieve the output stream</span>

<span class="co">// copy the input to the output character by character</span>
<span class="cf">for</span>(<span class="dt">uliteral_t</span> c : istream) {
    ostream &lt;&lt; c;
}</code></pre></div>
<h3 id="bitwise-io">Bitwise I/O</h3>
<p>The framework provides the classes <a href="../doxygen/classtdc_1_1io_1_1_bit_i_stream.html"><code>BitIStream</code></a> and <a href="../doxygen/classtdc_1_1io_1_1_bit_o_stream.html"><code>BitOStream</code></a> for bitwise input and output. They are wrappers around <code>std::istream</code> and <code>std::ostream</code>, respectively, and provide functionality to read or write single bits or fixed-width (MSBF order) integers from their underlying stream.</p>
<p>Single bits are written using <a href="../doxygen/classtdc_1_1io_1_1_bit_o_stream.html#a5528e8e10e99835223820f2e71a646bd"><code>write_bit</code></a>, integers using <a href="../doxygen/classtdc_1_1io_1_1_bit_o_stream.html#ac3239cf4964fd151ebd23954d63988fd"><code>write_int</code></a>.</p>
<p>The following example performs several bitwise write operations on an output:</p>
<div class="sourceCode" caption="bit_io.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
BitOStream obits(output); <span class="co">//construct the bitwise output stream</span>

obits.write_bit(<span class="dv">0</span>);     <span class="co">// write a single unset bit</span>
obits.write_bit(<span class="dv">1</span>);     <span class="co">// write a single set bit</span>
obits.write_int(<span class="dv">27</span>, <span class="dv">5</span>); <span class="co">// write the value 27 using 5 bits (11011)</span>
obits.write_int(<span class="dv">27</span>, <span class="dv">3</span>); <span class="co">// write the value 27 using 3 bits (truncated to 011)</span>

<span class="dt">int</span> a = <span class="dv">27</span>;
obits.write_int(a); <span class="co">// write the value 27 using 8*sizeof(int) bits (32)</span>
                    <span class="co">// (00000000000000000000000000011011)</span>

<span class="dt">uint8_t</span> b = <span class="dv">27</span>;
obits.write_int(b); <span class="co">// write the value 27 using 8*sizeof(uint8_t) bits (8)</span>
                    <span class="co">// (00011011)</span>

} <span class="co">// end of scope, write EOF sequence and destroy bit output stream</span></code></pre></div>
<p>There is important logic in the <a href="../doxygen/classtdc_1_1io_1_1_bit_o_stream.html#addd4d7bf8b766677b1cbc16fa281956b">destructor</a> of <code>BitOStream</code>: Since the stream writes bits to an underlying byte stream, it needs to write a few extra bits at the end of the stream in order to indicate the end for an eventual bit input stream.</p>
<p>Note how <a href="../doxygen/classtdc_1_1io_1_1_bit_o_stream.html#ac3239cf4964fd151ebd23954d63988fd"><code>write_int</code></a> will use the default size of the passed integer's type if no bit width is explicitly passed in the second argument.</p>
<p>The following example performs several bitwise read operations from an input:</p>
<div class="sourceCode" caption="bit_io.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp">BitIStream ibits(input); <span class="co">// construct the bitwise input stream</span>

<span class="dt">bool</span> bit = ibits.read_bit(); <span class="co">// read a single bit</span>

<span class="dt">uint8_t</span>  a = ibits.read_int&lt;<span class="dt">uint8_t</span>&gt;(<span class="dv">5</span>); <span class="co">// read a 5-bit integer into a uint8_t</span>
<span class="dt">uint16_t</span> b = ibits.read_int&lt;<span class="dt">uint16_t</span>&gt;(); <span class="co">// read a 16-bit integer</span></code></pre></div>
<p>Note how <a href="../doxygen/classtdc_1_1io_1_1_bit_i_stream.html#ae44308574bea503056059dd915b89cfb"><code>read_int</code></a> requires a template parameter in order to &quot;know&quot; into which data type the read integer will be stored and perform the respective conversion. If no bit width is given, the default size of the data type will be used.</p>
<p>Beyond writing single bits and fixed-width integers, the bit I/O features some universal integer encodings:</p>
<ul>
<li>Unary code (<a href="../doxygen/classtdc_1_1io_1_1_bit_o_stream.html#a49761f3046db6ad78af26ace2845e320"><code>write_unary</code></a> / <a href="../doxygen/classtdc_1_1io_1_1_bit_i_stream.html#a7a9509a64804ddac5f7dd27256851f8c"><code>read_unary</code></a>)</li>
<li>Elias gamma code (<a href="../doxygen/classtdc_1_1io_1_1_bit_o_stream.html#a0f5036f4793a2256e280e3d6f0270186"><code>write_elias_gamma</code></a> / <a href="../doxygen/classtdc_1_1io_1_1_bit_i_stream.html#ad5676d4691f2e9545f0851d8577893ee"><code>read_elias_gamma</code></a>)</li>
<li>Elias delta code (<a href="../doxygen/classtdc_1_1io_1_1_bit_o_stream.html#ab63d2915854e6ecbb8726926e7b44119"><code>write_elias_delta</code></a> / <a href="../doxygen/classtdc_1_1io_1_1_bit_i_stream.html#ac56bb4cd88cf4b278aa2703250951c4e"><code>read_elias_delta</code></a>)</li>
<li>Compressed integers (<a href="../doxygen/classtdc_1_1io_1_1_bit_o_stream.html#a429e4bc2c85045a495151d161f080d6d"><code>write_compressed_int</code></a> / <a href="../doxygen/classtdc_1_1io_1_1_bit_i_stream.html#a71634cc3060786e02e5ae9ca1629f017"><code>read_compressed_int</code></a>)</li>
</ul>
<h2 id="arbitrary-width-integer-vectors">Arbitrary-Width Integer Vectors</h2>
<p><em>tudocomp</em> provides types and classes to allow the use of arbitrary-width integers and vectors thereof. These are not limited to a default widths of 8, 16, 32 or 64 bits, but can be stored using any amount of bits as necessary.</p>
<p>The template class <a href="../doxygen/classtdc_1_1uint__t.html"><code>uint_t</code></a> is used to store single arbitrary-width integers. For instance, the specialization <code>uint_t&lt;40&gt;</code> can be used to represent values up to 2<sup>40</sup>-1. <code>uint_t</code> typically behaves like any other unsigned integer type, providing the respective operators and automatic casts.</p>
<p>The true power of arbitrary-width integers feature is unleashed by using the <a href="../doxygen/classtdc_1_1int__vector_1_1_int_vector.html"><code>IntVector</code></a> class to store sequences of them. Instead of storing values in a byte-aligned way like standard vectors, <code>IntVector</code> stores them as a sequence of bits. This can dramatically reduce the size of vectors when the optimal bit width required for storing a single is not a power of two.</p>
<p><code>IntVector</code> can be used in two different ways:</p>
<dl>
<dt>Static:</dt>
<dd>The bit width of values is fixed at compile time. This is the standard behaviozr if, for example, <code>IntVector&lt;uint_t&lt;40&gt;&gt;</code> is used for vectors of 40-bit integers.
</dd>
<dd>A common use case for this is also the <a href="../doxygen/namespacetdc.html#a393098dfa57d20d082394cdaa8e61d96"><code>BitVector</code></a> specialization, an alias for <code>IntVector&lt;uint_t&lt;1&gt;&gt;</code>, which effectively implements bit vectors.
</dd>
<dt>Dynamic:</dt>
<dd>The bit width of values can be dynamically altered at runtime.
</dd>
<dd>This is useful when the required width depends on previously processed input (e.g. a text length). It can also be used to bit-compress an integer vector after its initial construction.
</dd>
<dd>For this, the specialization <a href="../doxygen/namespacetdc.html#a52f0bacbb2e33c486c47e8f351545852"><code>DynamicIntVector</code></a> is used (which is merely an alias for <code>IntVector&lt;dynamic_t&gt;</code>).
</dd>
</dl>
<p>The following example illustrates the use of <code>IntVector</code> in a static way:</p>
<div class="sourceCode" caption="int_vector.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// reserve a vector of 32 4-bit integers (initialized as zero)</span>
IntVector&lt;<span class="dt">uint_t</span>&lt;<span class="dv">4</span>&gt;&gt; iv4(<span class="dv">32</span>);

<span class="co">// fill it with increasing values (0, 1, 2, ...)</span>
<span class="bu">std::</span>iota(iv4.begin(), iv4.end(), <span class="dv">0</span>);

<span class="co">// print size in bits</span>
LOG(INFO) &lt;&lt; <span class="st">&quot;Size of iv4 in bits: &quot;</span> &lt;&lt; iv4.bit_size();

<span class="co">// demonstrate overflow</span>
ASSERT_EQ(iv4[<span class="dv">0</span>], iv4[<span class="dv">16</span>]);

<span class="co">// reserve an additional bit vector with 32 entries</span>
BitVector bv(<span class="dv">32</span>);

<span class="co">// mark all multiples of 3</span>
<span class="cf">for</span>(<span class="dt">len_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">32</span>; i++) bv[i] = ((iv4[i] % <span class="dv">3</span>) == <span class="dv">0</span>);</code></pre></div>
<p>This example also demonstrates how <code>IntVector</code> is implemented in a fully STL-compatible way.</p>
<p>Note how arbitrary-width integers overflow in the expected fashion: <code>iv4[16]</code> (which should be 16 according to <a href="http://en.cppreference.com/w/cpp/algorithm/iota"><code>std::iota</code></a>) equals <code>iv4[0]</code> (which is zero).</p>
<p>The following is an example for the usage of <code>DynamicIntVector</code>:</p>
<div class="sourceCode" caption="int_vector.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// reserve a vector for 20 integer values (initialized as zero)</span>
<span class="co">// default to a width of 32 bits per value</span>
DynamicIntVector fib(<span class="dv">20</span>, <span class="dv">0</span>, <span class="dv">32</span>);

<span class="co">// fill it with the Fibonacci sequence</span>
fib[<span class="dv">0</span>] = <span class="dv">0</span>;
fib[<span class="dv">1</span>] = <span class="dv">1</span>;
<span class="cf">for</span>(<span class="dt">len_t</span> i = <span class="dv">2</span>; i &lt; fib.size(); i++)
  fib[i] = fib[i - <span class="dv">2</span>] + fib[i - <span class="dv">1</span>];

<span class="co">// find the amount of bits required to store the last (and largest) value</span>
<span class="kw">auto</span> max_bits = bits_for(fib.back());

<span class="co">// bit-compress the vector to the amount of bits required</span>
fib.width(max_bits);
fib.shrink_to_fit();</code></pre></div>
<p>Upon termination of this example, the vector will have a bit width of 13, which is the amount of bits required to store the 20<sup>th</sup> Fibonacci number (6,765).</p>
<p>The <a href="../doxygen/namespacetdc.html#a405c60e1a5ca678359687ce198b5036b"><code>bits_for</code></a> function is used to determine the amount of bits by computing the rounded-up binary logarithm. In the <a href="../doxygen/classtdc_1_1int__vector_1_1_int_vector.html#a4801e2d63351264c768a9e5ffd0fe05b">constructor</a> and using <a href="../doxygen/classtdc_1_1int__vector_1_1_int_vector.html#ad6c5d92faaf526f19576243c2b8a4bcd"><code>width</code></a>, the bit width of values within the <code>DynamicIntVector</code> can be altered at runtime. In order to achieve bit-compression, because the integer vector is internally backed by an array of 64-bit integers, a call to <a href="../doxygen/classtdc_1_1int__vector_1_1_int_vector.html#ac25b4515b1106354a765f430cfd8d0c2"><code>shrink_to_fit</code></a> is necessary in order to actually shrink the vector's capacity.</p>
<h2 id="algorithms">Algorithms</h2>
<p>The <a href="../doxygen/classtdc_1_1_algorithm.html"><code>Algorithm</code></a> class plays a central role in <em>tudocomp</em> as it provides the base for the modular system of compressors, coders and other classes - they all inherit from <code>Algorithm</code>.</p>
<p>This section introduces the core mechanisms one needs to understand in order to properly implement algorithms.</p>
<h3 id="meta-information">Meta Information</h3>
<p>Any <code>Algorithm</code> implementation needs to provide meta information about itself in the form of a <a href="../doxygen/classtdc_1_1_meta.html"><code>Meta</code></a> object. For this, inheriting (non-abstract) classes are expected to expose a static function called <code>meta</code>. The following is a minimal example:</p>
<div class="sourceCode" caption="algorithm_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="at">static</span> Meta meta() {
    Meta m(<span class="st">&quot;example&quot;</span>, <span class="st">&quot;my_algorithm&quot;</span>, <span class="st">&quot;An example algorithm&quot;</span>);
    <span class="cf">return</span> m;
}</code></pre></div>
<p>The <a href="../doxygen/classtdc_1_1_meta.html#af920817c2c17729c65f75598284f584e">constructor</a> takes three parameters:</p>
<ol style="list-style-type: decimal">
<li>The algorithm's type</li>
<li>The unique identifier for the algorithm</li>
<li>A brief human-readable description of the algorithm</li>
</ol>
<p>These parameters are used by the algorithm registry, which is explained further in the <a href="#the-algorithm-registry">respective section</a> below. For now, it is enough to understand that this information is later exposed to the command-line application.</p>
<h3 id="environment">Environment</h3>
<p>When instantiated, an algorithm receives an environment object (<a href="../doxygen/classtdc_1_1_env.html"><code>Env</code></a>) via its <a href="../doxygen/classtdc_1_1_algorithm.html#a7829ccc7b55c1b5a9192cf1c92091a4d">constructor</a>. The environment provides access to algorithm options as explained below. It is retrieved using the <a href="../doxygen/classtdc_1_1_algorithm.html#a57ce1a8c2d8d2c938274d61e786c33c2"><code>env</code></a> function.</p>
<h3 id="options">Options</h3>
<p>Algorithms can accept optional parameters, or arguments. These can be passed via the command-line or when instantiating an algorithm.</p>
<p>Options are declared in the algorithm's <code>Meta</code> object using the <a href="../doxygen/classtdc_1_1_meta.html#aa00cbc180eecd9017e247d9bbffbc01e"><code>option</code></a> function like in the following example:</p>
<div class="sourceCode" caption="algorithm_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="at">static</span> Meta meta() {
    Meta m(<span class="st">&quot;example&quot;</span>, <span class="st">&quot;my_algorithm&quot;</span>, <span class="st">&quot;An example algorithm&quot;</span>);
    m.option(<span class="st">&quot;param1&quot;</span>).dynamic(<span class="st">&quot;default_value&quot;</span>);
    m.option(<span class="st">&quot;number&quot;</span>).dynamic(<span class="dv">147</span>);
    <span class="cf">return</span> m;
}</code></pre></div>
<p>As visible in this example, options have basic type features. Only <a href="../doxygen/classtdc_1_1_meta_1_1_option_builder.html#a41d5ef14d440fc44b6f7ba91fcd7797e"><code>dynamic</code></a> options are shown here, which can be seen as options with primitive data attached to them (e.g. a string or a numeric value).</p>
<p>At runtime, options can be accessed via the algorithm's environment:</p>
<div class="sourceCode" caption="algorithm_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// read options</span>
<span class="kw">auto</span>&amp; param1 = env().option(<span class="st">&quot;param1&quot;</span>).as_string();
<span class="kw">auto</span> number = env().option(<span class="st">&quot;number&quot;</span>).as_integer();</code></pre></div>
<p>Because option values can be passed via the command-line, they are per se typeless. Using the conversion functions provided by the <a href="../doxygen/classtdc_1_1_option_value.html"><code>OptionValue</code></a> class, they can be cast to the required type (in the example: <a href="../doxygen/classtdc_1_1_meta_1_1_option_builder.html#a41d5ef14d440fc44b6f7ba91fcd7797e"><code>as_string</code></a> and <a href="../doxygen/classtdc_1_1_meta_1_1_option_builder.html#a41d5ef14d440fc44b6f7ba91fcd7797e"><code>as_integer</code></a>).</p>
<h3 id="strategies">Strategies</h3>
<p>The true power of <em>tudocomp</em>'s modularity comes from the ability to declare and pass strategies (or &quot;sub algorithms&quot;) as algorithm options.</p>
<p>Assuming the algorithm implementation has been declared with a template parameter <code>strategy_t</code>, the following declares it as an option in the <code>meta</code> function:</p>
<div class="sourceCode" caption="algorithm_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp">m.option(<span class="st">&quot;strategy&quot;</span>).templated&lt;<span class="dt">strategy_t</span>&gt;(<span class="st">&quot;my_strategy_t&quot;</span>);</code></pre></div>
<p>The function <a href="../doxygen/classtdc_1_1_meta_1_1_option_builder.html#a24ce72265c785c2ecd100f15ca6672c5"><code>templated</code></a> determines that the option named &quot;strategy&quot; can be assigned with an object of the template type. It is expected that substitued types also inherit from <code>Algorithm</code> and provide a <code>Meta</code> object.</p>
<p>The additional constraint, <code>&quot;my_strategy_t&quot;</code>, requires strategy algorithm to be of type &quot;my_strategy_t&quot;. This corresponds to an Algorithm's type as reported by its <code>Meta</code> object.</p>
<p>Consider the following example function for the algorithm:</p>
<div class="sourceCode" caption="algorithm_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="kw">virtual</span> <span class="dt">int</span> execute() <span class="kw">override</span> {
    <span class="co">// read number option as an integer</span>
    <span class="kw">auto</span> number = env().option(<span class="st">&quot;number&quot;</span>).as_integer();

    <span class="co">// instantiate strategy with sub environment</span>
    <span class="dt">strategy_t</span> strategy(env().env_for_option(<span class="st">&quot;strategy&quot;</span>));

    <span class="co">// use strategy to determine result</span>
    <span class="cf">return</span> strategy.result(number);
}</code></pre></div>
<p>This function creates an instance of the template algorithm <code>strategy_t</code>. The instance receives a new environment, ie., the strategy can accept options of its own (example provded in the following section). The strategy is then used to compute a result value using a <code>result</code> function, that receives the &quot;number&quot; option as a parameter.</p>
<h3 id="instantiating-algorithms">Instantiating Algorithms</h3>
<p>Consider the following two strategies that both implement the <code>result</code> function as required by the example from the previous section:</p>
<div class="sourceCode" caption="algorithm_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Strategy to compute the square of the input parameter</span>
<span class="kw">class</span> SquareStrategy : <span class="kw">public</span> Algorithm {
<span class="kw">public</span>:
    <span class="kw">inline</span> <span class="at">static</span> Meta meta() {
        <span class="co">// define the algorithm&#39;s meta information</span>
        Meta m(<span class="st">&quot;my_strategy_t&quot;</span>, <span class="st">&quot;sqr&quot;</span>, <span class="st">&quot;Computes the square&quot;</span>);
        <span class="cf">return</span> m;
    }

    <span class="kw">using</span> Algorithm::Algorithm; <span class="co">// inherit the default constructor</span>

    <span class="kw">inline</span> <span class="dt">int</span> result(<span class="dt">int</span> x) {
        <span class="cf">return</span> x * x;
    }
};

<span class="co">// Strategy to compute the product of the input parameter and another number</span>
<span class="kw">class</span> MultiplyStrategy : <span class="kw">public</span> Algorithm {
<span class="kw">public</span>:
    <span class="kw">inline</span> <span class="at">static</span> Meta meta() {
        <span class="co">// define the algorithm&#39;s meta information</span>
        Meta m(<span class="st">&quot;my_strategy_t&quot;</span>, <span class="st">&quot;mul&quot;</span>, <span class="st">&quot;Computes a product&quot;</span>);
        m.option(<span class="st">&quot;factor&quot;</span>).dynamic(); <span class="co">// no default</span>
        <span class="cf">return</span> m;
    }

    <span class="kw">using</span> Algorithm::Algorithm; <span class="co">// inherit the default constructor</span>

    <span class="kw">inline</span> <span class="dt">int</span> result(<span class="dt">int</span> x) {
        <span class="cf">return</span> x * env().option(<span class="st">&quot;factor&quot;</span>).as_integer();
    }
};</code></pre></div>
<p>Note how both strategies inherit from <code>Algorithm</code> and provide a <code>Meta</code> object. Both are of type <code>my_strategy_t</code> as required by the &quot;strategy&quot; option of the main algorithm.</p>
<p><code>SquareStrategy</code> implements a simple <code>result</code> function that squares the input parameter, while <code>MultiplyStrategy</code> accepts another option named &quot;factor&quot;, that is read and multiplied by the inpt parameter to compute the result.</p>
<p>The following example creates instances of the main algorithm from the previous section (called <code>MyAlgorithm</code>) with each of the strategies and computes the result values:</p>
<div class="sourceCode" caption="algorithm_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Execute the algorithm with the square strategy</span>
<span class="kw">auto</span> algo_sqr  = create_algo&lt;MyAlgorithm&lt;SquareStrategy&gt;&gt;(<span class="st">&quot;number=7&quot;</span>);
algo_sqr.execute(); <span class="co">// the result is 49</span>

<span class="co">// Execute the algorithm with the multiply strategy</span>
<span class="kw">auto</span> algo_mul5 = create_algo&lt;MyAlgorithm&lt;MultiplyStrategy&gt;&gt;(<span class="st">&quot;number=7, strategy=mul(factor=5)&quot;</span>);
algo_mul5.execute(); <span class="co">// the result is 35</span></code></pre></div>
<p><a href="../doxygen/namespacetdc.html#a69fd23d7f97c90afc49913cb3976c096"><code>create_algo</code></a> takes an algorithm type as a template parameter, in this case <code>MyAlgorithm</code> populated with the respective strategies. The string parameter contains the command-line options to be passed to the algorithm.</p>
<p>For <code>SquareStrategy</code>, the &quot;number&quot; option is simply set to 7, ie. the result of <code>execute</code> using this strategy will be 7 * 7 = 49.</p>
<p>For <code>MultiplyStrategy</code>, note how the &quot;strategy&quot; option is assigned the value of <code>mul(factor=5)</code>. A recursion takes place here: <code>mul</code> is the identifier of the <code>MultiplyStrategy</code> as exposed by its <code>Meta</code> information. It accepts the &quot;factor&quot; option, which is assigned the number 5. Thus, the result of <code>execute</code> in this case will be 7 * 5 = 35.</p>
<h3 id="the-algorithm-registry">The Algorithm Registry</h3>
<p>The ability of passing algorithms as command-line strings becomes most interesting when a <a href="../doxygen/classtdc_1_1_registry.html"><code>Registry</code></a> for algorithms gets added to the mix. Note how in the previous section's example, <code>create_algo</code> is called with fixed template types. A registry can be used to map string identifiers to actual types to obscure fixed typing.</p>
<p>The following example creates a registry and registers the example algorithm with the two strategies. It is then used to instantiate both versions without the need of fixed typing:</p>
<div class="sourceCode" caption="algorithm_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Create a registry for algorithms of type &quot;example&quot;</span>
Registry&lt;MyAlgorithmBase&gt; registry(<span class="st">&quot;example&quot;</span>);

<span class="co">// Register two specializations of the algorithm</span>
registry.register_algorithm&lt;MyAlgorithm&lt;SquareStrategy&gt;&gt;();
registry.register_algorithm&lt;MyAlgorithm&lt;MultiplyStrategy&gt;&gt;();

<span class="co">// Execute the algorithm with the square strategy</span>
<span class="kw">auto</span> algo_sqr = registry.select(<span class="st">&quot;my_algorithm(number=5, strategy=sqr)&quot;</span>);
algo_sqr-&gt;execute(); <span class="co">// the result is 25</span>

<span class="co">// Execute the algorithm with the multiply strategy</span>
<span class="kw">auto</span> algo_mul = registry.select(<span class="st">&quot;my_algorithm(number=5, strategy=mul(8))&quot;</span>);
algo_mul-&gt;execute(); <span class="co">// the result is 40</span></code></pre></div>
<p>Note that for this example, the interface <code>MyAlgorithmBase</code> was introduced, which <code>MyAlgorithm</code> inherits from. It merely declares the virtual function <code>execute</code>. The additional layer of abstraction is necessary only for use as a template parameter for the <code>Registry</code> class in this example.</p>
<h2 id="coders">Coders</h2>
<p>Coders serve for encoding primitve data types into a bit sequence with limited context. This is contrary to compressors, which may have random access the entire input sequence.</p>
<p>They only have a limited context that is determined by a controlling entity - most commonly a compressor. This context consists of <em>value ranges</em> and information on the <em>input alphabet</em>.</p>
<p>While compressors should provide as much context information as possible, it is up to the coder to actually make use of it or only parts of it.</p>
<h3 id="ranges">Ranges</h3>
<p>The <a href="../doxygen/classtdc_1_1_range.html"><code>Range</code></a> class serves as a representation of value ranges, ie., a minimum and a maximum value. Having information on the range that a certain value is contained in can help to encode the value in an efficient manner, namely using less bits.</p>
<p>For example, if a value <em>x</em> should be encoded and it is known to that <em>1024 &lt;= x &lt; 1088</em>, the coder could make use of this information in various ways:</p>
<ul>
<li>Encode only the difference <em>d<sub>x</sub> = x - 1024</em>.</li>
<li>Encode the difference using only 6 bits (because <em>d<sub>x</sub> &lt; 64</em> holds).</li>
<li>If it is also known that <em>x</em> tends to be distributed towards the minimum value, use variable-width encoding for <em>d<sub>x</sub></em>.</li>
<li>...</li>
</ul>
<p><em>tudocomp</em> provides several classes of ranges that should be used as precisely as possible in order to provide the best possible context information to coders:</p>
<table>
<thead>
<tr class="header">
<th>Class</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="../doxygen/classtdc_1_1_range.html"><code>Range</code></a></td>
<td>A simple min-max-range with no particular distribution.</td>
</tr>
<tr class="even">
<td><a href="../doxygen/classtdc_1_1_min_distributed_range.html"><code>MinDistributedRange</code></a></td>
<td>Values tend to be distributed towards the minimum.</td>
</tr>
<tr class="odd">
<td><a href="../doxygen/namespacetdc.html#a03d5c7581ed3cba7312a32c14e33d906"><code>BitRange</code></a></td>
<td>Values are either <em>0</em> or <em>1</em>.</td>
</tr>
<tr class="even">
<td><a href="../doxygen/classtdc_1_1_type_range.html"><code>TypeRange&lt;T&gt;</code></a></td>
<td>Values are of a certain integer type <code>T</code>.</td>
</tr>
<tr class="odd">
<td><a href="../doxygen/classtdc_1_1_literal_range.html"><code>LiteralRange</code></a></td>
<td>Values are literals (of type <code>uliteral_t</code>, see below).</td>
</tr>
</tbody>
</table>
<p>For literals, that is, characters of the input alphabet (commonly represented using the <a href="../doxygen/namespacetdc.html#a83a48cf82def7e8690fa0f1c92996486"><code>uliteral_t</code></a> type), <code>LiteralRange</code> / <code>uliteral_r</code> serves a special purpose and should be favored. The following section on literal iterators will provide more information.</p>
<p><em>tudocomp</em> also predefines global instances for some fixed common ranges: <a href="../doxygen/namespacetdc.html#a247a904fd8b4d4245d6f5c53b6a5d6dd"><code>uliteral_r</code></a> for <code>LiteralRange</code>, <a href="../doxygen/namespacetdc.html#aec12d4210d9d256411da11752a3a6943"><code>len_r</code></a> for <code>TypeRange&lt;len_t&gt;</code> and <a href="../doxygen/namespacetdc.html#af5e318a7c73a8b5501d780c7278a5f1e"><code>bit_r</code></a> for <code>BitRange</code>.</p>
<h3 id="literal-iterators">Literal Iterators</h3>
<p>Another useful piece of context information for coders may be about the input alphabet, that is, the characters or bytes (henceforth called &quot;literals&quot;) that occur and where they occur. This information can be used for low-entropy coding, with the most prominent example being Huffman codes.</p>
<p>In order to provide coders with information on the input literals, <em>tudocomp</em> offers the concept of a <a href="../doxygen/classtdc_1_1_literal_iterator.html"><code>LiteralIterator</code></a>. The literal iterator must define the two functions <a href="../doxygen/classtdc_1_1_literal_iterator.html#a1f35c6b3ddb3a06b604f75e448d9e72b"><code>has_next</code></a> and <a href="../doxygen/classtdc_1_1_literal_iterator.html#a9d011a0607038abd9530b85b52596e89"><code>next</code></a> to navigate over the input literals. The latter yields <a href="../doxygen/structtdc_1_1_literal.html"><code>Literal</code></a> objects, which contain an observed literal as well as a position at which it occurs.</p>
<p>The most simple form of a literal iterator would report every literal from the input in sequential order along with their position. For example, for the input text <code>&quot;aba&quot;</code>, it would yield the following Literal objects (represented as tuples of literal and position of occurence: <code>(a,1)</code>, <code>(b,2)</code>, <code>(a,3)</code>. This most simple behavior is implemented in the <a href="../doxygen/classtdc_1_1_view_literals.html"><code>ViewLiterals</code></a> class.</p>
<p>However, there are situations where this does not correspond to the literal occurences of an already processed input. A simple example is the LZ77 factorization of a text: Some literals have been replaced by factors and would, if still counted, distort the distribution of literals for a Huffman encoding. Therefore, the literal iterator that a LZ77 compressor passes to its encoder would skip any literal that has been replaced by a factor, in order to allow for a better low-entropy encoding afterwards. This commonly results in more complex implementations of the aforementioned functions <code>has_next</code> and <code>next</code>.</p>
<p>For some scenarios, especially during development, the <a href="../doxygen/classtdc_1_1_no_literals.html"><code>NoLiterals</code></a> iterator can be used to give no input alphabet information to the coder at all. Note that low-entropy encoders, which may rely on this information, may not be compatible with this.</p>
<h3 id="the-coder-interface">The Coder Interface</h3>
<p><em>tudocomp</em> does not provide a central base for coders, but separates their functionality by providing an <a href="../doxygen/classtdc_1_1_encoder.html"><code>Encoder</code></a> and a <a href="../doxygen/classtdc_1_1_decoder.html"><code>Decoder</code></a> class.</p>
<p>It is expected that for any encoder, there is a corresponding decoder that restores the original output. In order to enforce this, encoder and decoder implementations are typically encapsulated in an outer <code>Coder</code> class that inheirty from <code>Algorithm</code>. This design pattern allows for separation of encoding and decoding functionality while retaining the ability to instantiate both from a template type (ie. the outer class).</p>
<p>Apart from this concept, encoders and decoders are simple classes that declare the function templates <a href="../doxygen/classtdc_1_1_encoder.html#a8c5bb8464e2156db884ad99fa5e5ce55"><code>encode</code></a> and <a href="../doxygen/classtdc_1_1_encoder.html#a9a38f2ce545994adea94ec109e7b77df"><code>decode</code></a>, respectively. Their template parameters are generally expected to be numeric types.</p>
<p>Both <code>encode</code> and <code>decode</code> accept a <code>Range</code> as an argument. As discussed in the <a href="#ranges"><code>Ranges</code></a> section above, the range information can be used to encode a given value in a more efficient manner. The following example uses the range in order to perform a binary encoding of the given value:</p>
<div class="sourceCode" caption="coder_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> <span class="dt">value_t</span>&gt;
<span class="kw">inline</span> <span class="dt">void</span> encode(<span class="dt">value_t</span> v, <span class="at">const</span> Range&amp; r) {
    <span class="co">// Compute the amount of bits required to store a value of range r</span>
    <span class="kw">auto</span> delta_bits = bits_for(r.delta());

    <span class="co">// Encode the value as binary using the computed amount of bits</span>
    v -= r.min();
    <span class="va">m_out</span>-&gt;write_int(v, delta_bits);
}</code></pre></div>
<p>The range's <a href="../doxygen/classtdc_1_1_range.html#abaca808f80e0ccb79f3a752b06c762b5"><code>delta</code></a> is a convenience function that yields the difference between the range's <a href="../doxygen/classtdc_1_1_range.html#a346c267270e09dba72bcbb74a38f259a"><code>max</code></a> and <a href="../doxygen/classtdc_1_1_range.html#a55f24f213b216f4a534baf1aecd04542"><code>min</code></a> functions. In the example, the amount of bits required to store <code>delta</code> as binary is computed using the already known function <a href="../doxygen/namespacetdc.html#a405c60e1a5ca678359687ce198b5036b"><code>bits_for</code></a>. Then, only the difference between the passed value and the range's minimum value is actually encoded.</p>
<p>The corresponding decoding function would be implemented in the following way:</p>
<div class="sourceCode" caption="coder_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> <span class="dt">value_t</span>&gt;
<span class="kw">inline</span> <span class="dt">value_t</span> decode(<span class="at">const</span> Range&amp; r) {
    <span class="co">// Compute the amount of bits required to store a value of range r</span>
    <span class="kw">auto</span> delta_bits = bits_for(r.delta());

    <span class="co">// Decode the value from binary reading the computed amount of bits</span>
    <span class="dt">value_t</span> v = <span class="va">m_in</span>-&gt;read_int&lt;<span class="dt">value_t</span>&gt;(delta_bits);
    v += r.min();
    <span class="cf">return</span> v;
}</code></pre></div>
<p>Again, the amount of bits for the range's delta is computed and the difference of the stored value and the minimum is decoded. In a final step, naturally, the range's minimum has to be added back in order to restore the original value.</p>
<p>Note that the decoder relies on its controller (e.g. a compressor) to provide the correct range information. In order for the above example to work, the same range has to be used to encode and decode each value.</p>
<h4 id="range-overloads">Range Overloads</h4>
<p>In order to realize a different behavior for different types of ranges (as presented in the <a href="#ranges"><code>Ranges</code></a> section), overloads of <code>encode</code> and <code>decode</code> are used. These overloads only differ to the default signature in that they accept more specialized Range objects. The following example realizes an ASCII encoding for single bits, as identified by the <a href="../doxygen/namespacetdc.html#a03d5c7581ed3cba7312a32c14e33d906"><code>BitRange</code></a>:</p>
<div class="sourceCode" caption="coder_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> <span class="dt">value_t</span>&gt;
<span class="kw">inline</span> <span class="dt">void</span> encode(<span class="dt">value_t</span> v, <span class="at">const</span> BitRange&amp; r) {
    <span class="co">// Encode single bits as ASCII</span>
    <span class="va">m_out</span>-&gt;write_int(v ? <span class="st">&#39;1&#39;</span> : <span class="st">&#39;0&#39;</span>);
}</code></pre></div>
<p>The same idea works with decoding:</p>
<div class="sourceCode" caption="coder_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> <span class="dt">value_t</span>&gt;
<span class="kw">inline</span> <span class="dt">value_t</span> decode(<span class="at">const</span> BitRange&amp; r) {
    <span class="co">// Decode an ASCII character and compare against &#39;0&#39;</span>
    <span class="dt">uint8_t</span> b = <span class="va">m_in</span>-&gt;read_int&lt;<span class="dt">uint8_t</span>&gt;();
    <span class="cf">return</span> (b != <span class="st">&#39;0&#39;</span>);
}</code></pre></div>
<p>Note that there is <em>no</em> virtual inheritance, and therefore no polymorphism, between the different range types. This may be a pitfall when trying to introduce new range types. Also note that the default <code>Encoder</code> and <code>Decoder</code> implementations provide overloads for the default <code>Range</code> (which do binary coding like above) as well as <code>BitRange</code> (which writes single bits).</p>
<h4 id="using-literal-iterators">Using Literal Iterators</h4>
<p>Encoders accept a literal iterator (see <a href="#literal-iterators">Literal Iterators</a>) via their <a href="../doxygen/classtdc_1_1_encoder.html#a44b425acb795cd27f4ed300843f58fbb"><code>constructor</code></a>. The following simple example uses the literal iterator to count the amount of occurences of each possible literal (0 to 255) in the input:</p>
<div class="sourceCode" caption="coder_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// count occurences of each literal</span>
<span class="bu">std::</span>memset(<span class="va">m_occ</span>, <span class="dv">0</span>, <span class="dv">256</span>);

<span class="cf">while</span>(literals.has_next()) {
    Literal l = literals.next();
    ++<span class="va">m_occ</span>[l.c];
}</code></pre></div>
<h3 id="interleaved-coding">Interleaved Coding</h3>
<p>In order to achieve better (smaller) results, multiple encoders could be used for different scenarios. For example, when encoding a LZ78 factorization, one could use binary coding for a factor ID, and Huffman coding for the appended literal. This is called interleaved coding, since both encoders would write to the same bit output stream.</p>
<p>Interleaved coding is currently <em>not fully supported</em> by <em>tudocomp</em>. The issue here is that coders may &quot;absorb&quot; a certain amount of literals before deciding what to encode (e.g. run-length encoders). When a different encoder writes values in the meantime, the output may be corrupted.</p>
<p>A solution for this issue is planned for the near future.</p>
<h3 id="available-coders">Available Coders</h3>
<p>Out of the box, <em>tudocomp</em> currently implements a set of coders, including:</p>
<ul>
<li>Human readable coding (ASCII, for debugging purposes)</li>
<li>Binary coding</li>
<li>Universal codes (e.g. Elias codes)</li>
<li>Statistic codes (e.g. Huffman code)</li>
</ul>
<p>A full list can be found in the inheritance diagram for the <a href="../doxygen/classtdc_1_1_encoder.html"><code>Encoder</code></a> class' API reference.</p>
<h2 id="compressors">Compressors</h2>
<p>Compressors transform an input into an output that can be losslessly restored to the original input. What conceptually separates them from Coders is that compressors may have random access on the entire input and use this to find information on how to achieve compression. Apart from being able to use properties of the input for compression, they can build a context for one or multiple coders to in order to encode single values efficiently.</p>
<p>On a code level, the (abstract) <a href="../doxygen/classtdc_1_1_compressor.html"><code>Compressor</code></a> class serves as the foundation for compression algorithm implementations. It declares the two virtual functions <a href="../doxygen/classtdc_1_1_compressor.html#a3e2f25adc4f41e9d7853db9ebf0b9655"><code>compress</code></a> and <a href="../doxygen/classtdc_1_1_compressor.html#a1f7f85a6dde6ad34693ff2bfd24ae3a8"><code>decompress</code></a> with the same signature: both receive an <code>Input</code> to read from and an <code>Output</code> to write to (see <a href="#input-and-output">Input and Output</a> section). In a single compression cycle the output produced by <code>decompress</code> must match the input received by <code>compress</code>.</p>
<p>Compressors also inherit from <code>Algorithm</code> (see <a href="#algorithms">Algorithms</a> section, ie., they must provide a meta information object, they own an environment to accept options, and they can be implemented in a modular way using strategies for certain sub-task. For instance, most commonly, encoding is done using a <a href="#coders">Coder</a> as a strategy.</p>
<p>The following code example provides a simple compressor implementation that uses an encoding strategy.</p>
<div class="sourceCode" caption="compressor_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Implement a simple compressor</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> <span class="dt">coder_t</span>&gt;
<span class="kw">class</span> MyCompressor : <span class="kw">public</span> Compressor {
<span class="kw">public</span>:
    <span class="kw">inline</span> <span class="at">static</span> Meta meta() {
        Meta m(<span class="st">&quot;compressor&quot;</span>, <span class="st">&quot;my_compressor&quot;</span>, <span class="st">&quot;An example compressor&quot;</span>);
        m.option(<span class="st">&quot;coder&quot;</span>).templated&lt;<span class="dt">coder_t</span>&gt;(<span class="st">&quot;coder&quot;</span>);
        <span class="cf">return</span> m;
    }

    <span class="kw">using</span> Compressor::Compressor;

    <span class="kw">virtual</span> <span class="dt">void</span> compress(Input&amp; input, Output&amp; output) <span class="kw">override</span> {
        <span class="co">// retrieve random access on the input</span>
        <span class="kw">auto</span> view = input.as_view();

        <span class="co">// find the lexicographically smallest and largest characters</span>
        <span class="dt">uliteral_t</span> c_min = ULITERAL_MAX;
        <span class="dt">uliteral_t</span> c_max = <span class="dv">0</span>;

        <span class="cf">for</span>(<span class="dt">uliteral_t</span> c : view) {
            c_min = <span class="bu">std::</span>min(c_min, c);
            c_max = <span class="bu">std::</span>max(c_max, c);
        }

        <span class="co">// instantiate the encoder using the whole input alphabet</span>
        <span class="kw">typename</span> <span class="dt">coder_t</span>::Encoder coder(
            env().env_for_option(<span class="st">&quot;coder&quot;</span>), output, ViewLiterals(view));

        <span class="co">// encode the smallest and largest characters</span>
        coder.encode(c_min, uliteral_r);
        coder.encode(c_max, uliteral_r);

        <span class="co">// define the range for all occuring characters</span>
        Range occ_r(c_max - c_min);

        <span class="co">// encode text</span>
        <span class="cf">for</span>(<span class="dt">uliteral_t</span> c : view) {
            coder.encode(c - c_min, occ_r);
        }
    }

    <span class="co">/* decompress - see source file */</span>
};</code></pre></div>
<p>The presented compression algorithm is very simple:</p>
<ol style="list-style-type: decimal">
<li>Determine the lexicographically smallest and largest characters <code>c_min</code> and <code>c_max</code> in the input text (using a simple linear scan).</li>
<li>Instantiate an encoder for the whole input alphabet (<code>ViewLiterals</code>).</li>
<li>Store <code>c_min</code> and <code>c_max</code> to the output by encoding them using the literal range <code>uliteral_r</code>.</li>
<li>Define a range that covers values from 0 to <code>c_max - c_min</code> as a hint for the encoder.</li>
<li>Encode only the difference <code>c - c_min</code> between each character <code>c</code> from the input and the smallest one, <code>c_min</code>, using the previously defined range.</li>
</ol>
<p>Note that this simple type of compression could as well be implemented as a coder (because it only requires the input alphabet as a context), but it already shows the two typical major phases of a compression routine:</p>
<p>Firstly, it scans the input - possibly multiple times - and stores information about how to compress the text (in this case by determining the alphabet bounds). Secondly, the input is encoded to a compressed output using that information (in this case by shrinking the character values to the minimally required interval).</p>
<p>The decompression simply reverses this by first decoding <code>c_min</code> and <code>c_max</code>, then decoding character by character using the same range that was used in the compression.</p>
<p>The meta information declares the compression algorithm's type as <code>compressor</code>. This is important for the command-line application, which considers algorithms of this type only for exposition.</p>
<h3 id="available-compressors">Available Compressors</h3>
<p>Out of the box, <em>tudocomp</em> currently implements a set of compressors, including:</p>
<ul>
<li>Lempel-Ziv based compressors (LZ77, LZ78 and variants)</li>
<li>Grammar-based compressors (RePair)</li>
<li>A bzip chain (Burrows-Wheeler transform, move-to-front and run-length coding)</li>
</ul>
<p>These compressors are implemented in a modular way, making sub-task solvers reusable and allowing for swift development of alternative strategies.</p>
<p>A full list can be found in the inheritance diagram for the <a href="../doxygen/classtdc_1_1_compressor.html"><code>Compressor</code></a> class' API reference.</p>
<h3 id="compressor-test-helpers">Compressor Test Helpers</h3>
<p><em>tudocomp</em> provides some help utilities to quickly implement unit tests for compressors, most prominently the function <a href="about:blank"><code>test::roundtrip</code></a>, which performs the following operations: It</p>
<ol style="list-style-type: decimal">
<li>instantiates the given compressor type (template),</li>
<li>passes the input string to the <code>compress</code> method,</li>
<li>tests the compression result against an optional expected result,</li>
<li>passes the compression result to the <code>decompress</code> method and</li>
<li>tests the decompression result against the original input string.</li>
</ol>
<p>This way, it spans an entire compression cycle for a given text.</p>
<p>The following two function templates provide one more utility for tests on a variety of strings:</p>
<ul>
<li><a href="about:blank"><code>test::roundtrip_batch</code></a> runs a function for a set of short border case strings like the empty string, runs of a single character, simple repetitions, unicode etc.</li>
<li><a href="about:blank"><code>test::on_generators</code></a> runs a function for a set of strings generated by <em>tudocomp</em>'s stock string generators (see <a href="#string-generators">String Generators</a> section for more information).</li>
</ul>
<p>In combination with the <code>roundtrip</code> function, these can be used to quickly run a range of compression cycle tests as in the following example:</p>
<div class="sourceCode" caption="compressor_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// perform border case compression tests using different encoders</span>
test::roundtrip_batch(test::roundtrip&lt;MyCompressor&lt;ASCIICoder&gt;&gt;);
test::roundtrip_batch(test::roundtrip&lt;MyCompressor&lt;BitCoder&gt;&gt;);
test::roundtrip_batch(test::roundtrip&lt;MyCompressor&lt;EliasDeltaCoder&gt;&gt;);

<span class="co">// perform compression tests on generated strings using different encoders</span>
test::on_string_generators(test::roundtrip&lt;MyCompressor&lt;EliasDeltaCoder&gt;&gt;, <span class="dv">15</span>);
test::on_string_generators(test::roundtrip&lt;MyCompressor&lt;BitCoder&gt;&gt;, <span class="dv">15</span>);
test::on_string_generators(test::roundtrip&lt;MyCompressor&lt;ASCIICoder&gt;&gt;, <span class="dv">15</span>);</code></pre></div>
<p>The example first executes roundtrip tests for the example compressor and different encoders, on both border case strings and then strin generators.</p>
<p>Note that the second parameter passed to <code>on_string_generators</code> is passed further to the respective generators to generate, e.g., the 15<sup>th</sup> Fibonacci string or the 15<sup>th</sup> Thue Morse word. It should therefore not be chosen too high.</p>
<h3 id="magic">Magic</h3>
<p>For decompression, it is important to identify what compressor has been used to produce a compressed output - often called a &quot;magic&quot; keyword.</p>
<p>It is intended by <em>tudocomp</em> that this is <em>not</em> the responsibility of a compressor to prepend this information to the output, but it is the application that has to take care of this.</p>
<h2 id="string-generators">String Generators</h2>
<p>String generators are used to generate input strings via the command-line (as described in the <a href="#command-line-tool">Command-line Tool</a> section) or for unit tests, to name some examples.</p>
<p>They are based on the <a href="../doxygen/classtdc_1_1_generator.html"><code>Generator</code></a> class, which inherits from <code>Algorithm</code> (see <a href="#algorithms">Algorithms</a>) and only need to implement the <a href="../doxygen/classtdc_1_1_generator.html#a192083b153b85091c5aa3d8f9b82381a"><code>generate</code></a> function.</p>
<p>In order to allow for convenient use within <em>tudocomp</em>, the actual generation should be implemented in a static function that receives all parameters directly instead of relying on an environment.</p>
<p>The following class fully implements a string generator that simply repeats an optional character an optional amount of times:</p>
<div class="sourceCode" caption="generator_impl.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> MyGenerator : <span class="kw">public</span> Generator {
<span class="kw">public</span>:
    <span class="kw">inline</span> <span class="at">static</span> Meta meta() {
        Meta m(<span class="st">&quot;generator&quot;</span>, <span class="st">&quot;my_compressor&quot;</span>, <span class="st">&quot;An example compressor&quot;</span>);
        m.option(<span class="st">&quot;length&quot;</span>).dynamic();
        m.option(<span class="st">&quot;char&quot;</span>).dynamic(<span class="st">&#39;a&#39;</span>);
        <span class="cf">return</span> m;
    }

    <span class="kw">inline</span> <span class="at">static</span> <span class="bu">std::</span>string generate(<span class="dt">size_t</span> length, <span class="dt">char</span> c) {
        <span class="cf">return</span> <span class="bu">std::</span>string(length, c);
    }

    <span class="kw">using</span> Generator::Generator;

    <span class="kw">inline</span> <span class="kw">virtual</span> <span class="bu">std::</span>string generate() <span class="kw">override</span> {
        <span class="cf">return</span> generate(
            env().option(<span class="st">&quot;length&quot;</span>).as_integer(),
            env().option(<span class="st">&quot;char&quot;</span>).as_integer());
    }
};</code></pre></div>
<h3 id="available-string-generators">Available String Generators</h3>
<p>Out of the box, <em>tudocomp</em> currently implements a set of string generators, including:</p>
<ul>
<li>Random strings with uniform character distribution</li>
<li>Fibonacci words</li>
<li>Thue-Morse strings</li>
<li>Run-Rich strings (Matsubara et al.)</li>
</ul>
<p>A full list can be found in the inheritance diagram for the <a href="../doxygen/classtdc_1_1_generator.html"><code>Generator</code></a> class' API reference.</p>
<h2 id="runtime-statistics">Runtime Statistics</h2>
<p><em>tudocomp</em> provides functionality to measure the running time and the amount of dynamically allocated memory (e.h. via <code>malloc</code> or <code>new</code>) over the application lifetime.</p>
<p>Runtime statistics are tracked in <em>phases</em>, ie. the running time and memory peak can be measured for individual stages during an algorithm's run. These phases may be nested, ie., a phase can consist of multiple other phases. When using the <em>tudocomp</em> command-line tool, a root phase is automatically started immediately before the selected algorithm starts.</p>
<p>The measured data can be retrieved in a JSON representation in order to visualize it using the <a href="#charter-web-application"><em>tudocomp Charter</em></a> or to process in a third-party application.</p>
<p>Statistics tracking is implemented by the <a href="../doxygen/classtdc_1_1_stat_phase.html"><code>StatPhase</code></a> class. By creating a <code>StatPhase</code> object, a new phase is started. The <a href="../doxygen/classtdc_1_1_stat_phase.html#a3eb2b4d977cf20d55a2bf362ed693fb5">constructor</a> accepts the phase's title as a string. The phase ends either when the object is destroyed (e.g. when it runs out of scope) or when the phase is split (see below). Any code executed within a phase is subject to time and memory measurement.</p>
<p>In order to receive meaningful results, each phase should &quot;clean up&quot; properly, ie., it should free any memory that is no longer needed after the phase is finished. This can be achieved using scopes, but the <code>StatPhase</code> class also offers a way to enforce clean phase-based programming using the <a href="../doxygen/classtdc_1_1_stat_phase.html#ae2ada798d47449c0e45fb4752eba179d"><code>StatPhase::wrap</code></a> functor. It receives a lambda that implements the phase and is allowed to return a result to the outer program flow.</p>
<p>The following example runs through a few different phases with different processing times and memory allocations (for demonstration purposes, this is realized using sleeping and simply array allocations):</p>
<div class="sourceCode" caption="stats.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp">StatPhase root(<span class="st">&quot;Root&quot;</span>);

<span class="co">// Phase 1</span>
StatPhase::wrap(<span class="st">&quot;Phase 1&quot;</span>, []{
    <span class="dt">char</span>* alloc1 = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">2048</span>];
    <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">30</span>));
    <span class="kw">delete</span>[] alloc1;
});

<span class="co">// Phase 2</span>
StatPhase::wrap(<span class="st">&quot;Phase 2&quot;</span>, []{
    <span class="dt">char</span>* alloc2 = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">3072</span>];

    <span class="co">// Phase 2.1</span>
    StatPhase::wrap(<span class="st">&quot;Phase 2.1&quot;</span>, []{
        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">30</span>));

        StatPhase::log(<span class="st">&quot;A statistic&quot;</span>, <span class="dv">147</span>);
        StatPhase::log(<span class="st">&quot;Another statistic&quot;</span>, <span class="fl">0.5</span>);
    });

    <span class="co">// Phase 2.2</span>
    StatPhase::wrap(<span class="st">&quot;Phase 2.2&quot;</span>, []{
        <span class="dt">char</span>* alloc2_2 = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">1024</span>];
        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">40</span>));
        <span class="kw">delete</span>[] alloc2_2;
    });

    <span class="kw">delete</span>[] alloc2;
});

<span class="co">// Print data in JSON representation to stdout</span>
root.to_json().str(<span class="bu">std::</span>cout);</code></pre></div>
<p>During any phase, custom statistics can be logged using the <a href="../doxygen/classtdc_1_1_stat_phase.html#a9d4036e3d03fca76b0c95c2af596068d"><code>StatPhase::log</code></a> method.</p>
<p>As seen in the last line, the JSON representation of the measured data can be retrieved using the <a href="../doxygen/classtdc_1_1_stat_phase.html#a7e2210a96c67e6a2067df30ef86e31ff"><code>to_json</code></a> function. For the above example, the following JSON output is produced:</p>
<div class="sourceCode"><pre class="sourceCode json"><code class="sourceCode json"><span class="fu">{</span>
    <span class="dt">&quot;memFinal&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">,</span>
    <span class="dt">&quot;memOff&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">,</span>
    <span class="dt">&quot;memPeak&quot;</span><span class="fu">:</span> <span class="dv">4096</span><span class="fu">,</span>
    <span class="dt">&quot;stats&quot;</span><span class="fu">:</span> <span class="ot">[]</span><span class="fu">,</span>
    <span class="dt">&quot;sub&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="fu">{</span>
        <span class="dt">&quot;memFinal&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">,</span>
        <span class="dt">&quot;memOff&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">,</span>
        <span class="dt">&quot;memPeak&quot;</span><span class="fu">:</span> <span class="dv">2048</span><span class="fu">,</span>
        <span class="dt">&quot;stats&quot;</span><span class="fu">:</span> <span class="ot">[]</span><span class="fu">,</span>
        <span class="dt">&quot;sub&quot;</span><span class="fu">:</span> <span class="ot">[]</span><span class="fu">,</span>
        <span class="dt">&quot;timeEnd&quot;</span><span class="fu">:</span> <span class="dv">3330592</span><span class="fu">,</span>
        <span class="dt">&quot;timeStart&quot;</span><span class="fu">:</span> <span class="dv">3330562</span><span class="fu">,</span>
        <span class="dt">&quot;title&quot;</span><span class="fu">:</span> <span class="st">&quot;Phase 1&quot;</span>
    <span class="fu">}</span><span class="ot">,</span><span class="fu">{</span>
        <span class="dt">&quot;memFinal&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">,</span>
        <span class="dt">&quot;memOff&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">,</span>
        <span class="dt">&quot;memPeak&quot;</span><span class="fu">:</span> <span class="dv">4096</span><span class="fu">,</span>
        <span class="dt">&quot;stats&quot;</span><span class="fu">:</span> <span class="ot">[]</span><span class="fu">,</span>
        <span class="dt">&quot;sub&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="fu">{</span>
            <span class="dt">&quot;memFinal&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">,</span>
            <span class="dt">&quot;memOff&quot;</span><span class="fu">:</span> <span class="dv">3072</span><span class="fu">,</span>
            <span class="dt">&quot;memPeak&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">,</span>
            <span class="dt">&quot;stats&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="fu">{</span>
                <span class="dt">&quot;key&quot;</span><span class="fu">:</span> <span class="st">&quot;A statistic&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;value&quot;</span><span class="fu">:</span> <span class="st">&quot;147&quot;</span>
            <span class="fu">}</span><span class="ot">,</span><span class="fu">{</span>
                <span class="dt">&quot;key&quot;</span><span class="fu">:</span> <span class="st">&quot;Another statistic&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;value&quot;</span><span class="fu">:</span> <span class="st">&quot;0.500000&quot;</span>
            <span class="fu">}</span><span class="ot">]</span><span class="fu">,</span>
            <span class="dt">&quot;sub&quot;</span><span class="fu">:</span> <span class="ot">[]</span><span class="fu">,</span>
            <span class="dt">&quot;timeEnd&quot;</span><span class="fu">:</span> <span class="dv">3330623</span><span class="fu">,</span>
            <span class="dt">&quot;timeStart&quot;</span><span class="fu">:</span> <span class="dv">3330592</span><span class="fu">,</span>
            <span class="dt">&quot;title&quot;</span><span class="fu">:</span> <span class="st">&quot;Phase 2.1&quot;</span>
        <span class="fu">}</span><span class="ot">,</span><span class="fu">{</span>
            <span class="dt">&quot;memFinal&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">,</span>
            <span class="dt">&quot;memOff&quot;</span><span class="fu">:</span> <span class="dv">3072</span><span class="fu">,</span>
            <span class="dt">&quot;memPeak&quot;</span><span class="fu">:</span> <span class="dv">1024</span><span class="fu">,</span>
            <span class="dt">&quot;stats&quot;</span><span class="fu">:</span> <span class="ot">[]</span><span class="fu">,</span>
            <span class="dt">&quot;sub&quot;</span><span class="fu">:</span> <span class="ot">[]</span><span class="fu">,</span>
            <span class="dt">&quot;timeEnd&quot;</span><span class="fu">:</span> <span class="dv">3330663</span><span class="fu">,</span>
            <span class="dt">&quot;timeStart&quot;</span><span class="fu">:</span> <span class="dv">3330623</span><span class="fu">,</span>
            <span class="dt">&quot;title&quot;</span><span class="fu">:</span> <span class="st">&quot;Phase 2.2&quot;</span>
        <span class="fu">}</span><span class="ot">]</span><span class="fu">,</span>
        <span class="dt">&quot;timeEnd&quot;</span><span class="fu">:</span> <span class="dv">3330663</span><span class="fu">,</span>
        <span class="dt">&quot;timeStart&quot;</span><span class="fu">:</span> <span class="dv">3330592</span><span class="fu">,</span>
        <span class="dt">&quot;title&quot;</span><span class="fu">:</span> <span class="st">&quot;Phase 2&quot;</span>
    <span class="fu">}</span><span class="ot">]</span><span class="fu">,</span>
    <span class="dt">&quot;timeEnd&quot;</span><span class="fu">:</span> <span class="dv">3330663</span><span class="fu">,</span>
    <span class="dt">&quot;timeStart&quot;</span><span class="fu">:</span> <span class="dv">3330562</span><span class="fu">,</span>
    <span class="dt">&quot;title&quot;</span><span class="fu">:</span> <span class="st">&quot;Root&quot;</span>
<span class="fu">}</span></code></pre></div>
<h4 id="iterative-phases">Iterative Phases</h4>
<p>In some cases, phases of an algorithm compute complex results and would make it complicated to express them in a single lambda return statement. In other use cases, one may want to end a phase and begin a new phase within loop iterations in order to visualize progress.</p>
<p>For these purposes, a phase can be &quot;split&quot; using the <a href="../doxygen/classtdc_1_1_stat_phase.html#ad07845511111415b949424aa9eb1ae23"><code>split</code></a> function. Splitting causes the current phase to end and a new phase to begin immediately. The following example demonstrates phase splitting:</p>
<div class="sourceCode" caption="stats.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Phase 3 (splitting)</span>
StatPhase::wrap(<span class="st">&quot;Phase 3&quot;</span>, []{
    <span class="co">// Phase 3.1 yields a complex result</span>
    StatPhase sub_phase(<span class="st">&quot;Phase 3.1&quot;</span>);

    <span class="dt">char</span>* result_part_1 = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">1024</span>];
    <span class="dt">char</span>* result_part_2 = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">2048</span>];
    <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">40</span>));

    <span class="co">// Phase 3.2 may use the result</span>
    sub_phase.split(<span class="st">&quot;Phase 3.2&quot;</span>);
    <span class="kw">delete</span>[] result_part_2;
    <span class="kw">delete</span>[] result_part_1;
    <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">60</span>));
});</code></pre></div>
<h4 id="pausing-and-resuming-memory-tracking">Pausing and Resuming Memory Tracking</h4>
<p>There may be situations where the measurement of certain data structures is not desired, e.g., if they only serve as temporary helpers during development. Memory tracking can be paused and resumed during any phase using the <a href="../doxygen/classtdc_1_1_stat_phase.html#a61616705e4965099cb21dc0fc4cba676"><code>StatPhase::pause_tracking</code></a> and <a href="../doxygen/classtdc_1_1_stat_phase.html#a1149c160613989e7b4f3d6076ed36887"><code>StatPhase::resume_tracking</code></a> functions, as demonstrated in the following snippet:</p>
<div class="sourceCode" caption="stats.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Allocate memory, but only track mem2</span>
StatPhase::pause_tracking();
<span class="dt">char</span>* mem1 = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">1024</span>];
StatPhase::resume_tracking();    

<span class="dt">char</span>* mem2 = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">2048</span>];

<span class="co">// Sleep</span>
<span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">100</span>));

<span class="co">// Free memory, but only track mem2</span>
StatPhase::pause_tracking();
<span class="kw">delete</span>[] mem1;
StatPhase::resume_tracking();

<span class="kw">delete</span>[] mem2;</code></pre></div>
<h3 id="charter-web-application">Charter Web Application</h3>
<p>The <a href="../charter">tudocomp Charter</a> is a JavaScript-based web application that visualizes the statistics JSON output. Based on the data, it plots a bar chart that displays the single phases of the compression run with their running time on the X axis and their peak heap memory usage on the Y axis.</p>
<p>The following figure shows the diagram corresponding from the JSON snippet from the previous section.</p>
<div class="figure">
<img src="media/charter_diagram.png" alt="A diagram plotted by the Charter." />
<p class="caption">A diagram plotted by the Charter.</p>
</div>
<p>Observe the bar corresponding to Phase 2.2: The shaded area within the phase bar visualizes the <em>memory offset</em> of the phase, ie., how much memory was already allocated at the beginning of the phase. Alas, the top border of the bar displays the global, application-wide memory peak during the phase, while the phase's local memory peak is the difference between the whole and the shaded area.</p>
<p>This information is explicitly printed in table view below the diagram. This is also where custom statistics are printed. The table view of a phase will also be displayed as a tooltip when the mouse is moved over its bar in the diagram.</p>
<p>The Charter provides several options to customize the chart, as well as exporting it as either a vector graphic (<code>svg</code>) or an image file (<code>png</code>).</p>
<h2 id="text-corpus">Text Corpus</h2>
<p>For testing and benchmarking purposes, <em>tudocomp</em> provides a utility to automatically download or generate a text corpus. For convenience, it also creates several prefixes of the included texts (200 MiB, 100 MiB 50 MiB, ...).</p>
<p>The collection includes the <a href="http://acube.di.unipi.it/tagme-dataset">tagme</a> and <a href="http://acube.di.unipi.it/hashtag-datasets">hashtag</a> datasets from the <a href="http://acube.di.unipi.it/datasets">Lab of Advanced Algorithms and Applications</a>, as well as the <a href="http://pizzachili.dcc.uchile.cl">Pizza&amp;Chili Corpus</a> (identified by the prefixes <code>pc</code> and <code>pcr</code> below).</p>
<p>The following collections are generated by <em>tudocomp</em> itself:</p>
<ul>
<li><code>commoncrawl</code> - composition of a random subset of <a href="http://commoncrawl.org">common crawl</a>, containing only the plain text (i.e., excluding header and markup) of websites in ASCII format.</li>
<li><code>wiki-all-vital</code> - plain text composition of about 10,000 of the <a href="https://en.wikipedia.org/wiki/Wikipedia:Vital_articles/Expanded">most vital Wikipedia articles</a>.</li>
</ul>
<p>The following table contains information relevant for text compression on each of the included texts:</p>
<table>
<thead>
<tr class="header">
<th>Text</th>
<th>σ</th>
<th>max lcp</th>
<th>avg lcp</th>
<th>bwt runs</th>
<th>z</th>
<th>max LZ77 factor</th>
<th>H<sub>0</sub></th>
<th>H<sub>1</sub></th>
<th>H<sub>2</sub></th>
<th>H<sub>3</sub></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>hashtag</code></td>
<td>179</td>
<td>54,075</td>
<td>84</td>
<td>63,014K</td>
<td>13,721K</td>
<td>54,056</td>
<td>4.59</td>
<td>3.06</td>
<td>2.69</td>
<td>2.46</td>
</tr>
<tr class="even">
<td><code>pc-dblp.xml</code></td>
<td>97</td>
<td>1,084</td>
<td>44</td>
<td>29,585K</td>
<td>7,035K</td>
<td>1,060</td>
<td>5.26</td>
<td>3.48</td>
<td>2.17</td>
<td>1.43</td>
</tr>
<tr class="odd">
<td><code>pc-dna</code></td>
<td>17</td>
<td>97,979</td>
<td>60</td>
<td>128,863K</td>
<td>13,970K</td>
<td>97,966</td>
<td>1.97</td>
<td>1.93</td>
<td>1.92</td>
<td>1.92</td>
</tr>
<tr class="even">
<td><code>pc-english</code></td>
<td>226</td>
<td>987,770</td>
<td>9390</td>
<td>72,032K</td>
<td>13,971K</td>
<td>987,766</td>
<td>4.52</td>
<td>3.62</td>
<td>2.95</td>
<td>2.42</td>
</tr>
<tr class="odd">
<td><code>pc-proteins</code></td>
<td>26</td>
<td>45,704</td>
<td>278</td>
<td>108,459K</td>
<td>20,875K</td>
<td>45,703</td>
<td>4.20</td>
<td>4.18</td>
<td>4.16</td>
<td>4.07</td>
</tr>
<tr class="even">
<td><code>pcr-cere</code></td>
<td>6</td>
<td>175,655</td>
<td>3541</td>
<td>10,422K</td>
<td>1,447K</td>
<td>175,643</td>
<td>2.19</td>
<td>1.81</td>
<td>1.81</td>
<td>1.80</td>
</tr>
<tr class="odd">
<td><code>pcr-einstein.en</code></td>
<td>125</td>
<td>935,920</td>
<td>45983</td>
<td>153K</td>
<td>496K</td>
<td>906,995</td>
<td>4.92</td>
<td>3.66</td>
<td>2.61</td>
<td>1.63</td>
</tr>
<tr class="even">
<td><code>pcr-kernel</code></td>
<td>161</td>
<td>2,755,550</td>
<td>149872</td>
<td>2,718K</td>
<td>775K</td>
<td>2,755,550</td>
<td>5.38</td>
<td>4.03</td>
<td>2.93</td>
<td>2.05</td>
</tr>
<tr class="odd">
<td><code>pcr-para</code></td>
<td>6</td>
<td>72,544</td>
<td>2268</td>
<td>13,576K</td>
<td>1,927K</td>
<td>70,680</td>
<td>2.12</td>
<td>1.88</td>
<td>1.88</td>
<td>1.87</td>
</tr>
<tr class="even">
<td><code>pc-sources</code></td>
<td>231</td>
<td>307,871</td>
<td>373</td>
<td>47,651K</td>
<td>11,542K</td>
<td>307,871</td>
<td>5.47</td>
<td>4.08</td>
<td>3.10</td>
<td>2.34</td>
</tr>
<tr class="odd">
<td><code>tagme</code></td>
<td>206</td>
<td>1,281</td>
<td>26</td>
<td>65,195K</td>
<td>13,841K</td>
<td>1,279</td>
<td>4.90</td>
<td>3.77</td>
<td>3.20</td>
<td>2.60</td>
</tr>
<tr class="even">
<td><code>wiki-all-vital</code></td>
<td>205</td>
<td>8,607</td>
<td>15</td>
<td>80,609K</td>
<td>16,274K</td>
<td>8,607</td>
<td>4.56</td>
<td>3.62</td>
<td>3.03</td>
<td>2.45</td>
</tr>
<tr class="odd">
<td><code>commoncrawl</code></td>
<td>115</td>
<td>246,266</td>
<td>1727</td>
<td>45,899K</td>
<td>10,791K</td>
<td>246,266</td>
<td>5.37</td>
<td>4.30</td>
<td>3.55</td>
<td>2.78</td>
</tr>
</tbody>
</table>
<p><em>Legend</em>:</p>
<ul>
<li><em>σ</em> is the alphabet size, i.e., the amount of distinct symbols occuring in the text.</li>
<li><em>max lcp</em> is the maximum value in the text's longest common prefix array.</li>
<li><em>avg lcp</em> is the average of all longest common prefix array values.</li>
<li><em>bwt runs</em> is the number of runs in the Burrows-Wheeler transform of the text (i.e., how often <code>BWT[i] != BWT[i-1]</code> occurs).</li>
<li><em>z</em> is the number of LZ77 factors (n window) for the text.</li>
<li><em>max LZ77 factor</em> is the length of the longest LZ77 factor (no window).</li>
<li><em>H<sub>k</sub></em> is the k-th order entropy of the text.</li>
</ul>
<h3 id="downloading-the-text-corpus">Downloading the Text Corpus</h3>
<p>The following <code>make</code> command will download all of the text corpii listed above into the repository's <code>etc/datasets</code> directory:</p>
<pre><code>$ make datasets</code></pre>
<p>There are also targets to download specific subsets only. All of them have the prefix <code>datasets_</code> and should be offered by make's tab completion in the shell.</p>
<h2 id="the-comparison-tool">The Comparison Tool</h2>
<p><em>tudocomp</em> contains a utility to compare running time, memory usage and compression rate for a range of compressors, called the comparison tool. It comes in the form of a Python 3 script located at <code>etc/compare.py</code>. Note that it prints a usage description when passing the <code>--help</code> parameter.</p>
<p>The tool uses <code>valgrind</code> to measure the memory actually used by a process. Therefore, recall at this point the restrictions when using it in a Windows environment (see <a href="#windows-support">Windows Support</a>).</p>
<p>The comparison tool will perform the following steps for each input file and each compressor defined in the comparison suite (more details on suites follows further below):</p>
<ol style="list-style-type: decimal">
<li>Compress the input file and measure the compressor's running time</li>
<li>Compress the input file while measuring the compressor's memory usage</li>
<li>Compute the compression rate (size of output file divided by the input file's size).</li>
<li>Decompress the output file and measure the decompressor's running time</li>
<li>Decompress the output file while measuring the decompressor's memory usage</li>
<li>Compare the decompressor's output against the original input file</li>
</ol>
<p>Memory measurement via <code>valgrind</code> slows the process down significantly, which is why the compressor / decompressor is executed twice in order to measure time and memory, respectively. In case <code>valgrind</code> is unavailable, memory measurement will not take place.</p>
<p>The gathered data is printed as a table like in the following example:</p>
<pre><code>File: datasets/pc_dna.1MB (1.0MiB, sha256=b668b098927d32c5a239aef82dba6d45a034a205e64bf153810a5fe6f88fe196)

 Compressor |   C Time |  C Memory |    C Rate |   D Time |  D Memory |  chk |
------------------------------------------------------------------------------
    gzip -1 |   33.0ms |    6.6MiB |  32.4776% |   22.5ms |    6.6MiB |   OK |
    gzip -9 |  711.0ms |    6.6MiB |  27.2440% |   10.2ms |    6.6MiB |   OK |
   bzip2 -1 |  123.5ms |    9.3MiB |  26.6178% |   51.9ms |    8.7MiB |   OK |
   bzip2 -9 |  124.4ms |   15.4MiB |  26.1772% |   58.7ms |   11.7MiB |   OK |
    lzma -1 |  120.3ms |   23.3MiB |  28.8488% |   30.9ms |   15.8MiB |   OK |
    lzma -9 |  763.0ms |  687.8MiB |  24.7587% |   26.5ms |   78.8MiB |   OK |</code></pre>
<p>The columns have the following meaning:</p>
<ul>
<li><em>Compressor</em>: display name of the compressor as defined in the comparison suite (see below)</li>
<li><em>C Time</em>: running time of the compressor</li>
<li><em>C Memory</em>: memory usage of the compressor</li>
<li><em>C Rate</em>: compression rate (output size divided by input size)</li>
<li><em>D Time</em>: running time of the decompressor</li>
<li><em>D Memory</em>: memory usage of the decompressor</li>
<li><em>chk</em>: <code>OK</code> if the decompessed file equals the original file (tested by comparing their respective SHA256 hashes), otherwise <code>FAIL</code></li>
</ul>
<p>Multiple iterations can be performed per file (by passing the <code>-n</code> parameter). In this case, the respective median values of all iterations will be printed.</p>
<h3 id="comparison-suites">Comparison Suites</h3>
<p>A comparison suite defines a range of compressor pairs to be compared. A compressor pair consists of a display name for the tabular output, as well as information on how to invoke the compressor and decompressor on a command-line level (ie. command, arguments, and how input / output is passed to them).</p>
<p>Technically speaking, a suite must be a valid Python statement that resolves to a list of <code>CompressorPair</code> objects. These are (named) tuples of a string (the display name) and two <code>Exec</code> objects that define the command-line interface for the compressor and decompressor, respectively. To that end, <code>Exec</code> contains the command-line to execute as well as means to pass input and output file information.</p>
<p>The following example defines a small suite for comparing <code>gzip</code> against a <em>tudocomp</em> implementation of LZ77 with subsequent Huffman coding:</p>
<div class="sourceCode" caption="compare_example.suite"><pre class="sourceCode py"><code class="sourceCode python">[
<span class="co"># gzip -1</span>
CompressorPair(name <span class="op">=</span> <span class="st">&#39;gzip&#39;</span>,
    compress   <span class="op">=</span> Exec(args<span class="op">=</span>[<span class="st">&#39;gzip&#39;</span>, <span class="st">&#39;-1&#39;</span>], inp<span class="op">=</span>StdIn, outp<span class="op">=</span>StdOut),
    decompress <span class="op">=</span> Exec(args<span class="op">=</span>[<span class="st">&#39;gzip&#39;</span>, <span class="st">&#39;-d&#39;</span>], inp<span class="op">=</span>StdIn, outp<span class="op">=</span>StdOut)),

<span class="co"># tudocomp with LZSS/LCP and Huffman</span>
CompressorPair(name <span class="op">=</span> <span class="st">&#39;tdc_lzss_lcp_huff&#39;</span>,
    compress   <span class="op">=</span> Exec(args<span class="op">=</span>[<span class="st">&#39;./tdc&#39;</span>, <span class="st">&#39;-a&#39;</span>, <span class="st">&#39;lzss_lcp(threshold=20,coder=huff)&#39;</span>],
                      outp<span class="op">=</span><span class="st">&#39;--output&#39;</span>),
    decompress <span class="op">=</span> Exec(args<span class="op">=</span>[<span class="st">&#39;./tdc&#39;</span>, <span class="st">&#39;-d&#39;</span>], outp<span class="op">=</span><span class="st">&#39;--output&#39;</span>))
]</code></pre></div>
<p>As noted above, an <code>Exec</code> object contains the basic command-line to invoke a compressor or decompressor as a string list in the <code>args</code> parameter. The parameters <code>inp</code> and <code>outp</code> define how input and output files are passed to the application. They have the following possible states (values):</p>
<ul>
<li>If <code>outp</code> equals <code>StdOut</code>, it is expected that the application prints its output to the standard output stream. In this case, the comparison tool pipes it into a file.</li>
<li>Similarly, when <code>inp</code> equals <code>StdIn</code>, the input file is piped into the application via standard input.</li>
<li>In case of a string value, it is used as an additional command-line parameter followed by the file name (e.g. for <code>--output</code> in the example above, <code>--output FILENAME</code> is appended to the command-line).</li>
<li>If unset (<code>None</code>), only the file name is appended to the command-line.</li>
</ul>
<p>The two helper functions <code>Tudocomp</code> and <code>StdCompressor</code> facilitate the definition of <em>tudocomp</em> command-lines and the standard Linux compressors, which read from stdin and write to stdout. They can be used to abbreviate the suite from the example above to the following:</p>
<div class="sourceCode" caption="compare_example2.suite"><pre class="sourceCode py"><code class="sourceCode python">[
<span class="co"># gzip -1</span>
StdCompressor(name<span class="op">=</span><span class="st">&#39;gzip&#39;</span>,
    binary<span class="op">=</span><span class="st">&#39;gzip&#39;</span>, cflags<span class="op">=</span>[<span class="st">&#39;-1&#39;</span>], dflags<span class="op">=</span>[<span class="st">&#39;-d&#39;</span>]),

<span class="co"># tudocomp with LZSS/LCP and Huffman</span>
Tudocomp(name<span class="op">=</span><span class="st">&#39;tdc_lzss_lcp_huff&#39;</span>,
    algorithm<span class="op">=</span><span class="st">&#39;lzss_lcp(threshold=20,coder=huff)&#39;</span>),
]</code></pre></div>
<p>Note that by default, the <em>tudocomp</em> binary is expected at <code>./tdc</code>, therefore the comparison tool should be run from a build directory.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Note that InkScape versions prior to <a href="http://wiki.inkscape.org/wiki/index.php/Release_notes/0.92">0.92</a> do not properly support the positioning of texts using CSS. Therefore, when older versions are used to import SVGs generated by <em>tudocomp</em>, texts will not be positioned correctly.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><code>valgrind</code> reportedly fails starting in Bash on Ubuntu on Windows before the Creators Update. The issue had been filed officially <a href="https://github.com/Microsoft/BashOnWindows/issues/1295">here</a>.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Currently, direct streaming from an <code>std::istream</code> is not supported. When an <code>Input</code> is constructed from an <code>istream</code>, the stream is fully read and buffered in memory. This is an implementation decision that may change in the future. Note that files, on the other hand, are not buffered and will always be streamed from disk directly.<a href="#fnref3">↩</a></p></li>
</ol>
</div>

        </div>
    </section>
    <footer>
    </footer>
</body>
</html>

